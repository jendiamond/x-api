{
  "assignments": [
    {
      "track_id": "clojure",
      "id": "bob",
      "track": "clojure",
      "slug": "bob",
      "files": {
        "bob_test.clj": "(ns bob-test\n  (:require [clojure.test :refer :all]))\n\n(load-file \"bob.clj\")\n\n(deftest responds-to-something\n  (is (= \"Whatever.\" (bob/response-for \"Tom-ay-to, tom-aaaah-to.\"))))\n\n(deftest responds-to-shouts\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WATCH OUT!\"))))\n\n(deftest responds-to-questions\n  (is (= \"Sure.\" (bob/response-for \"Does this cryogenic chamber make me look fat?\"))))\n\n(deftest responds-to-forceful-talking\n  (is (= \"Whatever.\" (bob/response-for \"Let's go make out behind the gym!\"))))\n\n(deftest responds-to-acronyms\n  (is (= \"Whatever.\" (bob/response-for \"It's OK if you don't want to go to the DMV.\"))))\n\n(deftest responds-to-forceful-questions\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WHAT THE HELL WERE YOU THINKING?\"))))\n\n(deftest responds-to-shouting-with-special-characters\n  (is (= \"Whoa, chill out!\" (bob/response-for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"))))\n\n(deftest responds-to-shouting-numbers\n  (is (= \"Whoa, chill out!\" (bob/response-for \"1, 2, 3 GO!\"))))\n\n(deftest responds-to-shouting-with-no-exclamation-mark\n  (is (= \"Whoa, chill out!\" (bob/response-for \"I HATE YOU\"))))\n\n(deftest responds-to-statement-containing-question-mark\n  (is (= \"Whatever.\" (bob/response-for \"Ending with ? means a question.\"))))\n\n(deftest responds-to-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"\"))))\n\n(deftest responds-to-prolonged-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"    \"))))\n\n(deftest responds-to-only-numbers\n  (is (= \"Whatever.\" (bob/response-for \"1, 2, 3\"))))\n\n(deftest responds-to-number-question\n  (is (= \"Sure.\" (bob/response-for \"4?\"))))\n\n(run-tests)\n",
        "project.clj": "(defproject bob \"0.1.0-SNAPSHOT\"\n  :description \"bob exercise.\"\n  :url \"https://github.com/exercism/xclojure/tree/master/bob\"\n  :source-paths [\"\"]\n  :test-paths [\"\"]\n  :dependencies [[org.clojure/clojure \"1.6.0\"]])\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "coffeescript",
      "id": "hello-world",
      "track": "coffeescript",
      "slug": "hello-world",
      "files": {
        "hello_world.spec.coffee": "HelloWorld = require \"./hello_world\"\ndescribe \"HelloWorld\", ->\n  hello_world = new HelloWorld()\n  it \"given no name\", ->\n    result = hello_world.hello()\n    expect(result).toEqual \"Hello, world!\"\n  it \"given the name 'Alice'\", ->\n    result = hello_world.hello 'Alice'\n    expect(result).toEqual \"Hello, Alice!\"\n  it \"given the name 'Bob'\", ->\n    result = hello_world.hello 'Bob'\n    expect(result).toEqual \"Hello, Bob!\"\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nRefer to the [Exercism help page](http://help.exercism.io/getting-started-with-coffeescript.html) for getting started with CoffeeScript.\n\nIn order to run the test, you can run the test file from the exercise directory. For example, if the test suite is called hello_world.spec.coffee, you can run the following command:\n    jasmine-node --coffee hello_world.spec.coffee\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "cpp",
      "id": "bob",
      "track": "cpp",
      "slug": "bob",
      "files": {
        "CMakeLists.txt": "# Get the exercise name from the current directory\nget_filename_component(exercise ${CMAKE_CURRENT_SOURCE_DIR} NAME)\n\n# Basic CMake project\ncmake_minimum_required(VERSION 2.8.11)\n\n# Name the project after the exercise\nproject(${exercise} CXX)\n\n# Locate Boost libraries: unit_test_framework, date_time and regex\nset(Boost_USE_STATIC_LIBS ON)\nset(Boost_USE_MULTITHREADED ON)\nset(Boost_USE_STATIC_RUNTIME OFF)\nfind_package(Boost 1.55 REQUIRED COMPONENTS unit_test_framework date_time regex)\n\n# Enable C++11 features on gcc/clang\nif(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(GNU|Clang)\")\n    set(CMAKE_CXX_FLAGS \"-std=c++11\")\nendif()\n\n# Configure to run all the tests?\nif(${EXERCISM_RUN_ALL_TESTS})\n    add_definitions(-DEXERCISM_RUN_ALL_TESTS)\nendif()\n\n# Get a source filename from the exercise name by replacing -'s with _'s\nstring(REPLACE \"-\" \"_\" file ${exercise})\n\n# Implementation could be only a header\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${file}.cpp)\n    set(exercise_cpp ${file}.cpp)\nelse()\n    set(exercise_cpp \"\")\nendif()\n\n# Build executable from sources and headers\nadd_executable(${exercise} ${file}_test.cpp ${exercise_cpp} ${file}.h)\n\n# We need boost includes\ntarget_include_directories(${exercise} PRIVATE ${Boost_INCLUDE_DIRS})\n\n# We need boost libraries\ntarget_link_libraries(${exercise} ${Boost_LIBRARIES})\n\n# Tell MSVC not to warn us about unchecked iterators in debug builds\nif(${MSVC})\n    set_target_properties(${exercise} PROPERTIES\n        COMPILE_DEFINITIONS_DEBUG _SCL_SECURE_NO_WARNINGS)\nendif()\n\n# Run the tests on every build\nadd_custom_command(TARGET ${exercise} POST_BUILD COMMAND ${exercise})\n",
        "bob_test.cpp": "#include \"bob.h\"\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n\nBOOST_AUTO_TEST_CASE(stating_something)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Tom-ay-to, tom-aaaah-to.\"));\n}\n\n#if defined(EXERCISM_RUN_ALL_TESTS)\nBOOST_AUTO_TEST_CASE(shouting)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WATCH OUT!\"));\n}\n\nBOOST_AUTO_TEST_CASE(asking_a_question)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Does this cryogenic chamber make me look fat?\"));\n}\n\nBOOST_AUTO_TEST_CASE(talking_forcefully)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Let's go make out behind the gym!\"));\n}\n\nBOOST_AUTO_TEST_CASE(using_acronyms_in_regular_speech)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"It's OK if you don't want to go to the DMV.\"));\n}\n\nBOOST_AUTO_TEST_CASE(forceful_questions)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WHAT THE HELL WERE YOU THINKING?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"1, 2, 3 GO!\"));\n}\n\nBOOST_AUTO_TEST_CASE(only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"1, 2, 3\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"4?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_special_characters)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_no_exclamation_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"I HATE YOU\"));\n}\n\nBOOST_AUTO_TEST_CASE(statement_containing_question_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Ending with a ? means a question.\"));\n}\n\nBOOST_AUTO_TEST_CASE(prattling_on)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Wait! Hang on.  Are you going to be OK?\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_trailing_whitespace)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Are you ok? \"));\n}\n\nBOOST_AUTO_TEST_CASE(silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"\"));\n}\n\nBOOST_AUTO_TEST_CASE(prolonged_silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"   \"));\n}\n#endif\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Getting Started\n\nMake sure you have read the [getting started with C++](http://help.exercism.io/getting-started-with-cpp.html)\npage on the [exercism help site](http://help.exercism.io/).  This covers\nthe basic information on setting up the development environment expected\nby the exercises.\n\n## Passing the Tests\n\nGet the first test compiling, linking and passing by following the [three\nrules of test-driven development](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd).\nCreate just enough structure by declaring namespaces, functions, classes,\netc., to satisfy any compiler errors and get the test to fail.  Then write\njust enough code to get the test to pass.  Once you've done that,\nuncomment the next test by moving the following line past the next test.\n\n```C++\n#if defined(EXERCISM_RUN_ALL_TESTS)\n```\n\nThis may result in compile errors as new constructs may be invoked that\nyou haven't yet declared or defined.  Again, fix the compile errors minimally\nto get a failing test, then change the code minimally to pass the test,\nrefactor your implementation for readability and expressiveness and then\ngo on to the next test.\n\nTry to use standard C++11 facilities in preference to writing your own\nlow-level algorithms or facilities by hand.  [CppReference](http://en.cppreference.com/)\nis a wiki reference to the C++ language and standard library.  If you\nare new to C++, but have programmed in C, beware of\n[C traps and pitfalls](http://www.slideshare.net/LegalizeAdulthood/c-traps-and-pitfalls-for-c-programmers).\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "csharp",
      "id": "leap",
      "track": "csharp",
      "slug": "leap",
      "files": {
        "LeapTest.cs": "using NUnit.Framework;\n\n[TestFixture]\npublic class LeapTest\n{\n    [Test]\n    public void Valid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1996), Is.True);\n    }\n\n    [Ignore]\n    [Test]\n    public void Invalid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1997), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_20th_century_is_not_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(1900), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_25th_century_is_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(2400), Is.True);\n    }\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure you're exercise file you're submitting is in the `exercism/csharp/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.cs` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/csharp/bob/bob.cs`.\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "elixir",
      "id": "bob",
      "track": "elixir",
      "slug": "bob",
      "files": {
        "bob.exs": "defmodule Teenager do\n  def hey(input) do\n    cond do\n\n    end\n  end\nend\n",
        "bob_test.exs": "if System.get_env(\"EXERCISM_TEST_EXAMPLES\") do\n  Code.load_file(\"example.exs\")\nelse\n  Code.load_file(\"bob.exs\")\nend\n\nExUnit.start\n\ndefmodule TeenagerTest do\n  use ExUnit.Case, async: true\n\n  test \"stating something\" do\n    assert Teenager.hey(\"Tom-ay-to, tom-aaaah-to.\") == \"Whatever.\"\n  end\n\n  test \"shouting\" do\n    # assert Teenager.hey(\"WATCH OUT!\") == \"Whoa, chill out!\"\n  end\n\n  test \"asking a question\" do\n    # assert Teenager.hey(\"Does this cryogenic chamber make me look fat?\") == \"Sure.\"\n  end\n\n  test \"talking forcefully\" do\n    # assert Teenager.hey(\"Let's go make out behind the gym!\") == \"Whatever.\"\n  end\n\n  test \"talking in capitals\" do\n    # assert Teenager.hey(\"This Isn't Shouting!\") == \"Whatever.\"\n  end\n\n  test \"shouting numbers\" do\n    # assert Teenager.hey(\"1, 2, 3 GO!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with special characters\" do\n    # assert Teenager.hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\") == \"Whoa, chill out!\"\n  end\n\n  test \"shouting with no exclamation mark\" do\n    # assert Teenager.hey(\"I HATE YOU\") == \"Whoa, chill out!\"\n  end\n\n  test \"statement containing question mark\" do\n    # assert Teenager.hey(\"Ending with ? means a question.\") == \"Whatever.\"\n  end\n\n  test \"silence\" do\n    # assert Teenager.hey(\"\") == \"Fine. Be that way!\"\n  end\n\n  test \"prolonged silence\" do\n    # assert Teenager.hey(\"  \") == \"Fine. Be that way!\"\n  end\n\n  test \"only numbers\" do\n    # assert Teenager.hey(\"1, 2, 3\") == \"Whatever.\"\n  end\n\n  test \"question with numbers\" do\n    # assert Teenager.hey(\"4?\") == \"Sure.\"\n  end\n\n  test \"shouting in Russian\" do\n    # Hopefully this is Russian for \"get out\"\n    # assert Teenager.hey(\"УХОДИТЬ\") == \"Whoa, chill out!\"\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Running tests\n\n```bash\n$ elixir bob_test.exs\n```\n\n(Replace `bob_test.exs` with the name of the test file.)\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "erlang",
      "id": "leap",
      "track": "erlang",
      "slug": "leap",
      "files": {
        "leap_tests.erl": "% To run tests:\n% erl -make\n% erl -noshell -eval \"eunit:test(leap, [verbose])\" -s init stop\n%\n\n-module(leap_tests).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\nleap_year_test() ->\n    ?assert(leap:leap_year(1996)).\n\nnon_leap_year_test() ->\n    ?assertNot(leap:leap_year(1997)).\n\ncentury_test() ->\n    ?assertNot(leap:leap_year(1900)).\n\nfourth_century_test() ->\n    ?assert(leap:leap_year(2400)).\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "fsharp",
      "id": "sum-of-multiples",
      "track": "fsharp",
      "slug": "sum-of-multiples",
      "files": {
        "SumOfMultiplesTest.fs": "﻿module SumOfMultiplesTest\n\nopen NUnit.Framework\nopen SumOfMultiples\n\n[<TestFixture>]\ntype SumOfMultiplesTest() =\n    let mutable sumOfMultiples = SumOfMultiples()\n    \n    [<Test>]\n    member tc.Sum_to_1() = \n        Assert.That(sumOfMultiples.To(0), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_3() = \n        Assert.That(sumOfMultiples.To(3), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_10() = \n        Assert.That(sumOfMultiples.To(10), Is.EqualTo(23))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_7_13_17_to_20() = \n        Assert.That(SumOfMultiples([7; 13; 17]).To(20), Is.EqualTo(51))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_43_47_to_10000() = \n        Assert.That(SumOfMultiples([43; 47]).To(10000), Is.EqualTo(2203160))",
        "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of 3 or 5 up to but not including that number.\n\nIf we list all the natural numbers below 10 that are multiples of 3 or\n5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nAllow the program to be configured to find the sum of multiples of\nnumbers other than 3 and 5.\n\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
      },
      "fresh": false
    },
    {
      "track_id": "go",
      "id": "leap",
      "track": "go",
      "slug": "leap",
      "files": {
        "cases_test.go": "package leap\n\n// Source: exercism/x-common\n// Commit: 945d08e Merge pull request #50 from soniakeys/master\n\nvar testCases = []struct {\n\tyear        int\n\texpected    bool\n\tdescription string\n}{\n\t{1996, true, \"leap year\"},\n\t{1997, false, \"non-leap year\"},\n\t{1998, false, \"non-leap even year\"},\n\t{1900, false, \"century\"},\n\t{2400, true, \"fourth century\"},\n\t{2000, true, \"Y2K\"},\n}\n",
        "leap_test.go": "package leap\n\nimport \"testing\"\n\n// Define a function IsLeapYear(int) bool.\n//\n// Also define an exported TestVersion with a value that matches\n// the internal testVersion here.\n\nconst testVersion = 1\n\n// Retired testVersions\n// (none) 4a9e144a3c5dc0d9773f4cf641ffe3efe48641d8\n\nfunc TestLeapYears(t *testing.T) {\n\tif TestVersion != testVersion {\n\t\tt.Fatalf(\"Found TestVersion = %v, want %v\", TestVersion, testVersion)\n\t}\n\tfor _, test := range testCases {\n\t\tobserved := IsLeapYear(test.year)\n\t\tif observed != test.expected {\n\t\t\tt.Fatalf(\"IsLeapYear(%d) = %t, want %t (%s)\",\n\t\t\t\ttest.year, observed, test.expected, test.description)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLeapYears(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range testCases {\n\t\t\tIsLeapYear(test.year)\n\t\t}\n\t}\n}\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nTo run the tests simply run the command `go test` in the exercise directory.\n\nFor more detailed info about the Go track see the [help\npage](http://help.exercism.io/getting-started-with-go.html).\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "go",
      "id": "clock",
      "track": "go",
      "slug": "clock",
      "files": {
        "cases_test.go": "package clock\n\n// Source: exercism/x-common\n// Commit: 269f498 Merge pull request #48 from soniakeys/custom-set-json\n\n// Test creating a new clock with an initial time.\nvar timeTests = []struct {\n\th, m int\n\twant string\n}{\n\t{8, 0, \"08:00\"},      // on the hour\n\t{9, 0, \"09:00\"},      // on the hour\n\t{11, 9, \"11:09\"},     // past the hour\n\t{11, 19, \"11:19\"},    // past the hour\n\t{24, 0, \"00:00\"},     // midnight is zero hours\n\t{25, 0, \"01:00\"},     // hour rolls over\n\t{1, 60, \"02:00\"},     // sixty minutes is next hour\n\t{0, 160, \"02:40\"},    // minutes roll over\n\t{25, 160, \"03:40\"},   // hour and minutes roll over\n\t{-1, 15, \"23:15\"},    // negative hour\n\t{-25, 0, \"23:00\"},    // negative hour rolls over\n\t{1, -40, \"00:20\"},    // negative minutes\n\t{1, -160, \"22:20\"},   // negative minutes roll over\n\t{-25, -160, \"20:20\"}, // negative hour and minutes both roll over\n}\n\n// Test adding and subtracting minutes.\nvar addTests = []struct {\n\th, m, a int\n\twant    string\n}{\n\t{10, 0, 3, \"10:03\"},     // add minutes\n\t{0, 45, 40, \"01:25\"},    // add to next hour\n\t{10, 0, 61, \"11:01\"},    // add more than one hour\n\t{23, 59, 2, \"00:01\"},    // add across midnight\n\t{5, 32, 1500, \"06:32\"},  // add more than one day (1500 min = 25 hrs)\n\t{0, 45, 160, \"03:25\"},   // add more than two hours with carry\n\t{10, 3, -3, \"10:00\"},    // subtract minutes\n\t{10, 3, -30, \"09:33\"},   // subtract to previous hour\n\t{10, 3, -70, \"08:53\"},   // subtract more than an hour\n\t{0, 3, -4, \"23:59\"},     // subtract across midnight\n\t{0, 0, -160, \"21:20\"},   // subtract more than two hours\n\t{5, 32, -1500, \"04:32\"}, // subtract more than one day (1500 min = 25 hrs)\n\t{6, 15, -160, \"03:35\"},  // subtract more than two hours with borrow\n}\n\n// Construct two separate clocks, set times, test if they are equal.\ntype hm struct{ h, m int }\n\nvar eqTests = []struct {\n\tc1, c2 hm\n\twant   bool\n}{\n\t// clocks with same time\n\t{\n\t\thm{15, 37},\n\t\thm{15, 37},\n\t\ttrue,\n\t},\n\t// clocks a minute apart\n\t{\n\t\thm{15, 36},\n\t\thm{15, 37},\n\t\tfalse,\n\t},\n\t// clocks an hour apart\n\t{\n\t\thm{14, 37},\n\t\thm{15, 37},\n\t\tfalse,\n\t},\n\t// clocks set 24 hours apart\n\t{\n\t\thm{10, 37},\n\t\thm{34, 37},\n\t\ttrue,\n\t},\n}\n",
        "clock_test.go": "package clock\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\n// Clock type API:\n//\n// Time(hour, minute int) Clock    // a \"constructor\"\n// (Clock) String() string         // a \"stringer\"\n// (Clock) Add(minutes int) Clock\n//\n// Add should also handle subtraction by accepting negative values.\n// To satisfy the readme requirement about clocks being equal, values of\n// your Clock type need to work with the == operator.\n//\n// It might help to study the time.Time type in the standard library\n// (https://golang.org/pkg/time/#Time) as a model.  See how constructors there\n// (Date and Now) return Time values rather than pointers.  Note also how\n// most time.Time methods have value receivers rather that pointer recievers.\n// For more background on this read\n// https://github.com/golang/go/wiki/CodeReviewComments#receiver-type.\n\nconst testVersion = 2\n\n// Retired testVersions\n// (none) 79937f6d58e25ebafe12d1cb4a9f88f4de70cfd6\n// 1      8d0cb8b617be2e36b2ca5ad2034e5f80f2372924\n\nfunc TestCreateClock(t *testing.T) {\n\tif TestVersion != testVersion {\n\t\tt.Fatalf(\"Found TestVersion = %v, want %v\", TestVersion, testVersion)\n\t}\n\tfor _, n := range timeTests {\n\t\tif got := Time(n.h, n.m); got.String() != n.want {\n\t\t\tt.Fatalf(\"Time(%d, %d) = %q, want %q\", n.h, n.m, got, n.want)\n\t\t}\n\t}\n\tt.Log(len(timeTests), \"test cases\")\n}\n\nfunc TestAddMinutes(t *testing.T) {\n\tfor _, a := range addTests {\n\t\tif got := Time(a.h, a.m).Add(a.a); got.String() != a.want {\n\t\t\tt.Fatalf(\"Time(%d, %d).Add(%d) = %q, want %q\",\n\t\t\t\ta.h, a.m, a.a, got, a.want)\n\t\t}\n\t}\n\tt.Log(len(addTests), \"test cases\")\n}\n\nfunc TestCompareClocks(t *testing.T) {\n\tfor _, e := range eqTests {\n\t\tclock1 := Time(e.c1.h, e.c1.m)\n\t\tclock2 := Time(e.c2.h, e.c2.m)\n\t\tgot := clock1 == clock2\n\t\tif got != e.want {\n\t\t\tt.Log(\"Clock1:\", clock1)\n\t\t\tt.Log(\"Clock2:\", clock2)\n\t\t\tt.Logf(\"Clock1 == Clock2 is %t, want %t\", got, e.want)\n\t\t\tif reflect.DeepEqual(clock1, clock2) {\n\t\t\t\tt.Log(\"(Hint: see comments in clock_test.go.)\")\n\t\t\t}\n\t\t\tt.FailNow()\n\t\t}\n\t}\n\tt.Log(len(eqTests), \"test cases\")\n}\n",
        "README.md": "# Clock\n\nImplement a clock that handles times without dates.\n\nCreate a clock that is independent of date.\n\nYou should be able to add and subtract minutes to it.\n\nTwo clocks that represent the same time should be equal to each other.\n\nTo run the tests simply run the command `go test` in the exercise directory.\n\nFor more detailed info about the Go track see the [help\npage](http://help.exercism.io/getting-started-with-go.html).\n\n## Source\n\nPairing session with Erin Drummond [view source](https://twitter.com/ebdrummond)\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "list-ops",
      "track": "haskell",
      "slug": "list-ops",
      "files": {
        "ListOps.hs": "module ListOps\n  ( length\n  , reverse\n  , map\n  , filter\n  , foldr\n  , foldl'\n  , (++)\n  , concat\n  ) where\n\nimport Prelude hiding\n  ( length, reverse, map, filter, foldr, (++), concat )\n\nfoldl' :: (b -> a -> b) -> b -> [a] -> b\nfoldl' = undefined\n\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr = undefined\n\nlength :: [a] -> Int\nlength = undefined\n\nreverse :: [a] -> [a]\nreverse = undefined\n\nmap :: (a -> b) -> [a] -> [b]\nmap = undefined\n\nfilter :: (a -> Bool) -> [a] -> [a]\nfilter = undefined\n\n(++) :: [a] -> [a] -> [a]\nxs ++ ys = undefined\n\nconcat :: [[a]] -> [a]\nconcat = undefined\n",
        "list-ops_test.hs": "{-# LANGUAGE DeriveDataTypeable #-}\n\nimport Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport qualified ListOps as L\nimport Control.Exception (Exception, throw, evaluate, try)\nimport Data.Typeable (Typeable)\n\ndata FoldlIsStrictException = FoldlIsStrictException deriving (Eq, Show, Typeable)\ninstance Exception FoldlIsStrictException\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList listOpsTests ]\n\n\nbig :: Int\nbig = 100000\n\nlistOpsTests :: [Test]\nlistOpsTests =\n  [ testCase \"length of empty list\" $ do\n    0 @=? L.length ([] :: [Int])\n  , testCase \"length of non-empty list\" $ do\n    4 @=? L.length [1 .. 4 :: Int]\n  , testCase \"length of large list\" $ do\n    big @=? L.length [1 .. big :: Int]\n  , testCase \"reverse of empty list\" $ do\n    [] @=? L.reverse ([] :: [Int])\n  , testCase \"reverse of non-empty list\" $ do\n    [100 , 99 .. 1] @=? L.reverse [1 .. 100 :: Int]\n  , testCase \"map of empty list\" $ do\n    [] @=? L.map (+1) ([] :: [Int])\n  , testCase \"map of non-empty list\" $ do\n    [2, 4 .. 8] @=? L.map (+1) [1, 3 .. 7 :: Int]\n  , testCase \"filter of empty list\" $ do\n    [] @=? L.filter undefined ([] :: [Int])\n  , testCase \"filter of normal list\" $ do\n    [1, 3] @=? L.filter odd [1 .. 4 :: Int]\n  , testCase \"foldl' of empty list\" $ do\n    0 @=? L.foldl' (+) (0 :: Int) []\n  , testCase \"foldl' of non-empty list\" $ do\n    7 @=? L.foldl' (+) (-3) [1 .. 4 :: Int]\n  , testCase \"foldl' of huge list\" $ do\n    big * (big + 1) `div` 2 @=? L.foldl' (+) 0 [1 .. big]\n  , testCase \"foldl' with non-commutative function\" $ do\n    0 @=? L.foldl' (-) 10 [1 .. 4 :: Int]\n  , testCase \"foldl' is not just foldr . flip\" $ do\n    \"fdsa\" @=? L.foldl' (flip (:)) [] \"asdf\"\n  , testCase \"foldl' is accumulator-strict (use seq or BangPatterns)\" $ do\n    r <- try . evaluate $\n      L.foldl' (flip const) () [throw FoldlIsStrictException, ()]\n    Left FoldlIsStrictException @=? (r :: Either FoldlIsStrictException ())\n  , testCase \"foldr as id\" $ do\n    [1 .. big] @=? L.foldr (:) [] [1 .. big]\n  , testCase \"foldr as append\" $ do\n    [1 .. big] @=? L.foldr (:) [100 .. big] [1 .. 99]\n  , testCase \"++ of empty lists\" $ do\n    [] @=? [] L.++ ([] :: [Int])\n  , testCase \"++ of empty and non-empty lists\" $ do\n    [1 .. 4] @=? [] L.++ [1 .. 4 :: Int]\n  , testCase \"++ of non-empty and empty lists\" $ do\n    [1 .. 4] @=? [1 .. 4 :: Int] L.++ []\n  , testCase \"++ of non-empty lists\" $ do\n    [1 .. 5] @=? [1 .. 3] L.++ [4, 5 :: Int]\n  , testCase \"++ of large lists\" $ do\n    [1 .. big] @=? [1 .. big `div` 2] L.++ [1 + big `div` 2 .. big]\n  , testCase \"concat of no lists\" $ do\n    [] @=? L.concat ([] :: [[Int]])\n  , testCase \"concat of list of lists\" $ do\n    [1 .. 6] @=? L.concat [[1, 2], [3], [], [4, 5, 6 :: Int]]\n  , testCase \"concat of large list of small lists\" $ do\n    [1 .. big] @=? L.concat (map (:[]) [1 .. big])\n  ]\n",
        "README.md": "# List Ops\n\nImplement basic list operations\n\nIn functional languages list operations like `length`, `map`, and\n`reduce` are very common. Implement a series of basic list operations,\nwithout using existing functions.\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "word-count",
      "track": "haskell",
      "slug": "word-count",
      "files": {
        "word-count_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport Data.Map (fromList)\nimport WordCount (wordCount)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nwordCountTests :: [Test]\nwordCountTests =\n  [ testCase \"count one word\" $\n    fromList [(\"word\", 1)] @=? wordCount \"word\"\n  , testCase \"count one of each\" $\n    fromList [(\"one\", 1), (\"of\", 1), (\"each\", 1)] @=? wordCount \"one of each\"\n  , testCase \"count multiple occurrences\" $\n    fromList [(\"one\", 1), (\"fish\", 4), (\"two\", 1),\n              (\"red\", 1), (\"blue\", 1)] @=?\n    wordCount \"one fish two fish red fish blue fish\"\n  , testCase \"ignore punctuation\" $\n    fromList [(\"car\", 1), (\"carpet\", 1), (\"as\", 1),\n              (\"java\", 1), (\"javascript\", 1)] @=?\n    wordCount \"car : carpet as java : javascript!!&@$%^&\"\n  , testCase \"include numbers\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"testing, 1, 2 testing\"\n  , testCase \"normalize case\" $\n    fromList [(\"go\", 3)] @=? wordCount \"go Go GO\"\n  , testCase \"prefix punctuation\" $\n    fromList [(\"testing\", 2), (\"1\", 1), (\"2\", 1)] @=?\n    wordCount \"!%%#testing, 1, 2 testing\"\n  , testCase \"symbols are separators\" $\n    fromList [(\"hey\", 1), (\"my\", 1), (\"spacebar\", 1),\n              (\"is\", 1), (\"broken\", 1)] @=?\n    wordCount \"hey,my_spacebar_is_broken.\"\n  ]\n\nmain :: IO ()\nmain = exitProperly (runTestTT (TestList wordCountTests))\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false
    },
    {
      "track_id": "haskell",
      "id": "leap",
      "track": "haskell",
      "slug": "leap",
      "files": {
        "leap_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport LeapYear (isLeapYear)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList isLeapYearTests ]\n\nisLeapYearTests :: [Test]\nisLeapYearTests =\n  [ testCase \"vanilla leap year\" $\n    True @=? isLeapYear 1996\n  , testCase \"any old year\" $\n    False @=? isLeapYear 1997\n  , testCase \"century\" $\n    False @=? isLeapYear 1900\n  , testCase \"exceptional century\" $\n    True @=? isLeapYear 2400\n  ]\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "track_id": "java",
      "id": "etl",
      "track": "java",
      "slug": "etl",
      "files": {
        "build.gradle": "apply plugin: \"java\"\napply plugin: \"eclipse\"\napply plugin: \"idea\"\n\nrepositories {\n  mavenCentral()\n}\n\ndependencies {\n  testCompile \"junit:junit:4.10\"\n  testCompile \"org.easytesting:fest-assert-core:2.0M10\"\n  testCompile \"com.google.guava:guava:16+\"\n}\n",
        "src/main/java/Etl.java": "",
        "src/test/java/EtlTest.java": "import com.google.common.collect.ImmutableMap;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class EtlTest {\n    private final Etl etl = new Etl();\n\n    @Test\n    public void testTransformOneValue() {\n        Map<Integer, List<String>> old = ImmutableMap.of(1, Arrays.asList(\"A\"));\n        Map<String, Integer> expected = ImmutableMap.of(\"a\", 1);\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testTransformMoreValues() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"i\", 1,\n                \"o\", 1,\n                \"u\", 1\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testMoreKeys() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\"),\n                2, Arrays.asList(\"D\", \"G\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"d\", 2,\n                \"g\", 2\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testFullDataset() {\n        Map<Integer, List<String>> old = ImmutableMap.<Integer, List<String>>builder().\n                put(1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\")).\n                put(2, Arrays.asList(\"D\", \"G\")).\n                put(3, Arrays.asList(\"B\", \"C\", \"M\", \"P\")).\n                put(4, Arrays.asList(\"F\", \"H\", \"V\", \"W\", \"Y\")).\n                put(5, Arrays.asList(\"K\")).\n                put(8, Arrays.asList(\"J\", \"X\")).\n                put(10, Arrays.asList(\"Q\", \"Z\")).\n                build();\n        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder().\n                put(\"a\", 1).put(\"b\", 3).put(\"c\", 3).put(\"d\", 2).put(\"e\", 1).\n                put(\"f\", 4).put(\"g\", 2).put(\"h\", 4).put(\"i\", 1).put(\"j\", 8).\n                put(\"k\", 5).put(\"l\", 1).put(\"m\", 3).put(\"n\", 1).put(\"o\", 1).\n                put(\"p\", 3).put(\"q\", 10).put(\"r\", 1).put(\"s\", 1).put(\"t\", 1).\n                put(\"u\", 1).put(\"v\", 4).put(\"w\", 4).put(\"x\", 8).put(\"y\", 4).\n                put(\"z\", 10).build();\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n}\n",
        "README.md": "# Etl\n\nWe are going to do the `Transform` step of an Extract-Transform-Load.\n\n### ETL\nExtract-Transform-Load (ETL) is a fancy way of saying, \"We have some crufty, legacy data over in this system, and now we need it in this shiny new system over here, so\nwe're going to migrate this.\"\n\n(Typically, this is followed by, \"We're only going to need to run this\nonce.\" That's then typically followed by much forehead slapping and\nmoaning about how stupid we could possibly be.)\n\n### The goal\nWe're going to extract some scrabble scores from a legacy system.\n\nThe old system stored a list of letters per score:\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThe shiny new scrabble system instead stores the score per letter, which\nmakes it much faster and easier to calculate the score for a word. It\nalso stores the letters in lower-case regardless of the case of the\ninput letters:\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- Etc.\n\nYour mission, should you choose to accept it, is to write a program that\ntransforms the legacy data format to the shiny new format.\n\n### Notes\nNote that both the old and the new system use strings to represent\nletters, even in languages that have a separate data type for\ncharacters.\n\nA final note about scoring, Scrabble is played around the world in a\nvariety of languages, each with its own unique scoring table. For\nexample, an \"A\" is scored at 14 in the Basque-language version of the\ngame while being scored at 9 in the Latin-language version.\n\n\n## Source\n\nThe Jumpstart Lab team [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "track_id": "javascript",
      "id": "hello-world",
      "track": "javascript",
      "slug": "hello-world",
      "files": {
        "hello-world.js": "//\n// This is only a SKELETON file for the 'Hello World' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nvar HelloWorld = function() {};\n\nHelloWorld.prototype.hello = function(input) {\n//\n// YOUR CODE GOES HERE\n//\n};\n\nmodule.exports = HelloWorld;\n",
        "hello-world_test.spec.js": "var HelloWorld = require('./hello-world');\n\ndescribe('Hello World', function() {\n  var helloWorld = new HelloWorld();\n\n  it('says hello world with no name', function() {\n    expect(helloWorld.hello('')).toEqual('Hello, world!');\n  });\n\n  xit('says hello to bob', function() {\n    expect(helloWorld.hello('Bob')).toEqual('Hello, Bob!');\n  });\n\n  xit('says hello to sally', function() {\n    expect(helloWorld.hello('Sally')).toEqual('Hello, Sally!');\n  });\n});\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n## Setup\n\nGo through the setup instructions for JavaScript to\ninstall the necessary dependencies:\n\nhttp://help.exercism.io/getting-started-with-javascript.html\n\n## Making the Test Suite Pass\n\nExecute the tests with:\n\n```bash\n$ jasmine-node .\n```\n\nIn many test suites all but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "lisp",
      "id": "point-mutations",
      "track": "lisp",
      "slug": "point-mutations",
      "files": {
        "dna.lisp": "(defpackage #:dna\n  (:use #:cl)\n  (:export #:hamming-distance))\n(in-package #:dna)\n\n(defun hamming-distance (dna1 dna2)\n  \"Determine number of mutations between DNA strands by computing the Hamming Distance.\"\n  )\n",
        "point-mutations-test.lisp": "(ql:quickload \"lisp-unit\")\n\n(defpackage #:point-mutations-test\n  (:use #:common-lisp #:lisp-unit))\n\n(load \"dna\")\n\n(in-package #:point-mutations-test)\n\n(define-test no-difference-between-empty-strands\n  (assert-equal 0 (dna:hamming-distance \"\" \"\")))\n\n(define-test no-difference-between-identical-strands\n  (assert-equal 0 (dna:hamming-distance \"GGACTGA\" \"GGACTGA\")))\n\n(define-test complete-hamming-distance-in-small-strand\n  (assert-equal 3 (dna:hamming-distance \"ACT\" \"GGA\")))\n\n(define-test small-hamming-distance-in-middle-somewhere\n  (assert-equal 1 (dna:hamming-distance \"GGACG\" \"GGTCG\")))\n\n(define-test larger-distance\n  (assert-equal 2 (dna:hamming-distance \"ACCAGGG\" \"ACTATGG\")))\n\n(define-test invalid-to-get-distance-for-different-length-strings\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGACATCTTTCAGCCGCCGGATTAGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGG\" \"AGACAACAGCCAGCCGCCGGATT\")))\n\n(let ((*print-errors* t)\n      (*print-failures* t))\n  (run-tests :all :point-mutations-test))\n",
        "README.md": "# Point Mutations\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. Hence you\nmay assume that only sequences of equal length will be passed to your hamming\ndistance function.\n\nCheck out\n[Exercism Help](http://help.exercism.io/getting-started-with-lisp.html)\nfor instructions to get started writing Common Lisp. That page will\nexplain how to install and setup a Lisp implementation and how to run\nthe tests.\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "lua",
      "id": "hello-world",
      "track": "lua",
      "slug": "hello-world",
      "files": {
        "hello-world_test.lua": "local HelloWorld = require('hello_world')\n\ndescribe('Hello World', function()\n\n  it('says hello world with no name', function()\n    local result = HelloWorld.hello()\n    assert.are.equals('Hello, world!', result)\n  end)\n\n  it('says hello to Bob', function()\n    local result = HelloWorld.hello('Bob')\n    assert.are.equals('Hello, Bob!', result)\n  end)\n\n  it('says hello to Sally', function()\n    local result = HelloWorld.hello('Sally')\n    assert.are.equals('Hello, Sally!', result)\n  end)\nend)\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n### Getting started\nFirst install lua using [homebrew][1]\n\n    $ brew install lua\n\nThen install [luarocks][2] to install packages for lua\n\n    $ brew install luarocks\n\nThen install [busted][3] testing framework for lua\n\n    $ luarocks install busted\n    \nThen run your test\n\n    $ busted bob_test.lua \n    \nOther resources\n\n  1. [Lua Style Guide][4]\n  2. [Learn Lua in 15 minutes][5] \n\n[1]: http://brew.sh/\n[2]: http://luarocks.org/\n[3]: http://olivinelabs.com/busted/\n[4]: https://github.com/Olivine-Labs/lua-style-guide\n[5]: http://tylerneylon.com/a/learn-lua/\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "objective-c",
      "id": "bob",
      "track": "objective-c",
      "slug": "bob",
      "files": {
        "BobTest.m": "#import <XCTest/XCTest.h>\n#import \"Bob.h\"\n\n@interface test_suite : XCTestCase\n\n@end\n\n@implementation test_suite\n\n- (Bob *)bob {\n  return [[Bob alloc] init];\n}\n\n- (void)testStatingSomething {\n  NSString *input = @\"Tom-ay-to, tom-aaaah-to.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testShouting {\n  NSString *input = @\"WATCH OUT!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testAskingAQuestion {\n  NSString *input = @\"Does this cryogenic chamber make me look fat?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testTalkingForcefully {\n  NSString *input = @\"Let's go make out behind the gym!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testUsingAcronyms {\n  NSString *input = @\"It's OK if you don't want to go to the DMV.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testForcefulQuestions {\n  NSString *input = @\"WHAT THE HELL WERE YOU THINKING?\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testShoutingNumbers {\n  NSString *input = @\"1, 2, 3 GO!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testOnlyNumbers {\n  NSString *input = @\"1, 2, 3.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n- (void)testQuestionWithOnlyNumbers {\n  NSString *input = @\"4?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testShoutingWithSpecialCharacters {\n  NSString *input = @\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testShoutingWithUmlautsCharacters {\n  NSString *input = @\"ÄMLÄTS!\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testCalmlySpeakingAboutUmlauts {\n  NSString *input = @\"ÄMLäTS!\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testShoutingWithNoExclamationMark {\n  NSString *input = @\"I HATE YOU\";\n  NSString *expected = @\"Whoa, chill out!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testStatementContainingQuestionsMark {\n  NSString *input = @\"Ending with a ? means a question.\";\n  NSString *expected = @\"Whatever.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testPrattlingOn {\n  NSString *input = @\"Wait! Hang on.  Are you going to be OK?\";\n  NSString *expected = @\"Sure.\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testSilence {\n  NSString *input = @\"\";\n  NSString *expected = @\"Fine. Be that way!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testProlongedSilence {\n  NSString *input = @\"     \";\n  NSString *expected = @\"Fine. Be that way!\";\n  NSString *result = [[self bob] hey:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n@end\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Setup\n\nThere are two different methods of getting set up to run the tests with Objective-C:\n\n- Create an Xcode project with a test target which will run the tests.\n- Use the ruby gem `objc` as a test runner utility.\n\nBoth are described in more detail here: http://help.exercism.io/getting-started-with-objective-c.html\n\n\n### Submitting Exercises\n\nWhen submitting an exercise, make sure your solution file is in the same directory as the test code.\n\nFor example, if you're submitting `Bob.m` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/objective-c/bob/Bob.m`.\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "ocaml",
      "id": "bob",
      "track": "ocaml",
      "slug": "bob",
      "files": {
        "Makefile": "test: test.native\n\t@./test.native\n\ntest.native: *.ml *.mli\n\t@corebuild -quiet test.native\n\nclean:\n\trm -rf _build\n\n.PHONY: clean\n",
        "bob.mli": "(*\nAnswers to `hey` like a teenager.\n\n## Examples\n\n  # response_for \"\"\n  \"Fine. Be that way!\"\n\n  # response_for \"Do you like math?\"\n  \"Sure.\"\n\n  # response_for \"HELLO!\"\n  \"Woah, chill out!\"\n\n  # response_for \"Coding is cool.\"\n  \"Whatever.\"\n*)\nval response_for : string -> string\n",
        "test.ml": "open Core.Std\nopen OUnit2\nopen Bob\n\nlet ae exp got _test_ctxt = assert_equal ~printer:String.to_string exp got\n\nlet tests =\n  [\"something\">::\n     ae \"Whatever.\" (response_for \"Tom-ay-to, tom-aaaah-to.\");\n   \"shouts\">::\n     ae \"Whoa, chill out!\" (response_for \"WATCH OUT!\");\n   \"questions\">::\n     ae \"Sure.\" (response_for \"Does this cryogenic chamber make me look fat?\");\n   \"forceful talking\">::\n     ae \"Whatever.\" (response_for \"Let's go make out behind the gym!\");\n   \"acronyms\">::\n     ae \"Whatever.\" (response_for \"It's ok if you don't want to go to the DMV.\");\n   \"forceful questions\">::\n     ae \"Whoa, chill out!\" (response_for \"WHAT THE HELL WERE YOU THINKING?\");\n   \"shouting with special characters\">::\n     ae \"Whoa, chill out!\"\n       (response_for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\");\n   \"shouting numbers\">::\n     ae \"Whoa, chill out!\" (response_for \"1, 2, 3, GO!\");\n   \"statement containing question mark\">::\n     ae \"Whatever.\" (response_for \"Ending with ? means a question.\");\n   \"silence\">::\n     ae \"Fine. Be that way!\" (response_for \"\");\n   \"prolonged silence\">::\n     ae \"Fine. Be that way!\" (response_for \"   \");\n   \"non-letters with question\">::\n     ae \"Sure.\" (response_for \":) ?\");\n   \"multiple line questons\">::\n     ae \"Whatever.\"\n       (response_for \"\\nDoes this cryogenic chamber make me look fat? \\nno\");\n   \"other whitespace\">::\n     (* No unicode whitespace as OCaml Core doesn't seem to handle Unicode.\n      * Not it seems does it see ASCII 11 (\\v) as whitespace.\n     *)\n     ae \"Fine. Be that way!\" (response_for \"\\n\\r \\t\");\n   \"only numbers\">::\n     ae \"Whatever.\" (response_for \"1, 2, 3\");\n   \"question with only numbers\">::\n     ae \"Sure.\" (response_for \"4?\");\n  ]\n\nlet () =\n  run_test_tt_main (\"bob tests\" >::: tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Running Tests\n\nBecause OCaml is a compiled language you need to compile your submission and the test code before you can run the tests. Compile with\n\n```bash\n$ corebuild -quiet test.native\n```\n\nand when successful run the tests by running the `test.native` executable:\n\n```bash\n./test.native\n```\n\nAlternatively just type\n\n```bash\nmake\n```\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "perl5",
      "id": "bob",
      "track": "perl5",
      "slug": "bob",
      "files": {
        "bob.pm": "#\n# This is a SKELETON file and has been provided to enable you to get working on the\n# first exercise more quickly.\n#\n\nuse 5.006;\nuse strict;\nuse warnings;\n\npackage Bob;\n\nour $VERSION = '1.000';\n\nuse Exporter 5.57 qw(import);\n\nour @EXPORT_OK = qw(hey);\n\nsub hey {\n#\n# YOUR CODE GOES HERE\n#\n}\n\n1;\n",
        "bob.t": "use strict;\nuse warnings;\nuse open ':std', ':encoding(utf8)';\nuse utf8;\n\nmy $module = $ENV{EXERCISM} ? 'Example' : 'Bob';\n\nuse Test::More;\n\nmy @cases = map {\n    {\n        input   => $_->[0],\n        expect  => $_->[1],\n        desc    => $_->[2],\n    }\n} (\n    # input                                             expected output       title\n    ['Tom-ay-to, tom-aaaah-to.',                       'Whatever.',          'stating something'],\n    ['WATCH OUT!',                                     'Whoa, chill out!',   'shouting'],\n    ['Does this cryogenic chamber make me look fat?',  'Sure.',              'question'],\n    ['You are, what, like 15?',                        'Sure.',              'numeric question'],\n    [\"Let's go make out behind the gym!\",              'Whatever.',          'talking forcefully'],\n    [\"It's OK if you don't want to go to the DMV.\",    'Whatever.',          'using acronyms in regular speech'],\n    ['WHAT THE HELL WERE YOU THINKING?',               'Whoa, chill out!',   'forceful questions'],\n    ['1, 2, 3 GO!',                                    'Whoa, chill out!',   'shouting numbers'],\n    ['1, 2, 3',                                        'Whatever.',          'only numbers'],\n    ['4?',                                             'Sure.',              'question with only numbers'],\n    ['ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!',  'Whoa, chill out!',   'shouting with special characters'],\n    [\"ÜMLÄÜTS!\",                                       'Whoa, chill out!',   'shouting with umlauts'],\n    [\"\\xdcML\\xc4\\xdcTS!\",                              'Whoa, chill out!',   'shouting with umlauts'],\n    ['_A',                                             'Whoa, chill out!',   'underscore shout - before'],\n    ['A_',                                             'Whoa, chill out!',   'underscore shout - after'],\n    ['$A',                                             'Whoa, chill out!',   'Dollar sign shout - before'],\n    ['A$',                                             'Whoa, chill out!',   'Dollar sign shout - after'],\n    [\"ÜMLäÜTS!\",                                       'Whatever.',          'speaking calmly with umlauts'],\n    ['I HATE YOU',                                     'Whoa, chill out!',   'shouting with no exclamation mark'],\n    ['Ending with ? means a question.',                'Whatever.',          'statement containing question mark'],\n    [\"Wait! Hang on. Are you going to be OK?\",         'Sure.',              'prattling on'],\n    ['',                                               'Fine. Be that way!', 'silence'],\n    ['    ',                                           'Fine. Be that way!', 'prolonged silence'],\n    [\"   \\nI just remembered...\",                      'Whatever.',          'Silence, then more'],\n);\n\nok -e \"$module.pm\", \"missing $module.pm\"\n    or BAIL_OUT(\"You need to create a module called $module.pm with a function called hey() that gets one parameter: The text Bob hears.\");\n\nuse_ok($module)\n    or BAIL_OUT(\"Does $module.pm compile?  Does it end with 1; ?\");\n\ncan_ok($module, 'hey')\n    or BAIL_OUT(\"Missing package $module; or missing sub hey()\");\n\nmy $sub = $module->can('hey');\n\nforeach my $c (@cases) {\n    #diag uc $c->{input};\n    my $title = $c->{desc} ? \"$c->{desc}: $c->{input}\" : $c->{input};\n    is $sub->( $c->{input} ), $c->{expect}, $title;\n}\n\ndone_testing();\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "track_id": "php",
      "id": "hamming",
      "track": "php",
      "slug": "hamming",
      "files": {
        "hamming.php": "<?php\n\n//\n// This is only a SKELETON file for the \"Hamming\" exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nfunction distance($a, $b)\n{\n    //\n    // YOUR CODE GOES HERE\n    //\n}\n",
        "hamming_test.php": "<?php\n\nrequire \"hamming.php\";\n\nclass HammingComparatorTest extends PHPUnit_Framework_TestCase\n{\n\n    public function testNoDifferenceBetweenIdenticalStrands()\n    {\n        $this->assertEquals(0, distance('A', 'A'));\n    }\n\n    public function testCompleteHammingDistanceOfForSingleNucleotideStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('A', 'G'));\n    }\n\n    public function testCompleteHammingDistanceForSmallStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(2, distance('AG', 'CT'));\n    }\n\n    public function testSmallHammingDistance()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('AT', 'CT'));\n    }\n\n    public function testSmallHammingDistanceInLongerStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('GGACG', 'GGTCG'));\n    }\n\n    public function testLargeHammingDistance()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(4, distance('GATACA', 'GCATAA'));\n    }\n\n    public function testHammingDistanceInVeryLongStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(9, distance('GGACGGATTCTG', 'AGGACGGATTCT'));\n    }\n\n    public function testExceptionThrownWhenStrandsAreDifferentLength()\n    {\n        $this->markTestSkipped();\n        $this->setExpectedException('InvalidArgumentException', 'DNA strands must be of equal length.');\n        distance('GGACG', 'AGGACGTGG');\n    }\n}\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n## Making the Test Suite Pass\n\n1. Get [PHPUnit].\n\n        % wget --no-check-certificate https://phar.phpunit.de/phpunit.phar\n        % chmod +x phpunit.phar\n\n2. Execute the tests for an assignment.\n\n        % phpunit.phar wordy/wordy_test.php\n\n[PHPUnit]: http://phpunit.de\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "plsql",
      "id": "hamming",
      "track": "plsql",
      "slug": "hamming",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\n## Setup\n\nYou'll need access to a mounted Oracle DB. If you don't have one already\ninstalled, here are a few options:\n* download VirtualBox from Oracle and run one of the freely\navailable images; at the time of writing, the easiest to get started with\nat the time of writing might be _Database App Development VM_. The\nimage is quite large...\n* download and install the a version of the Oracle DB itself. Developer licenses\nare free.\n* get a free workspace at https://apex.oracle.com\n\n**Note**: if you're using the online version of APEX, compilation errors will\nnot be indicated very clearly when working in _SQL Commands_ - you will simply\nget \"Error at line XX: PL/SQL: Statement ignored\"... More insight can be\nfound using the _Object Browser_ and navigating to the object you created\n(select either _Packages_ or _Procedures_ in the dropdown menu showing _Tables_,\ndepending on what you created for the exercise). Also, when you run statements,\n\"run\" each individual `create` statement individually by selecting its text.\nAPEX does not seem to like doing too much work at once...\n\nTo work on individual problems, a nice and free way is to use SQL Developer. If \nyou don't want to use yet another IDE, you can simply copy and paste your code\ninto a terminal / command prompt connected to the database. The files are\nprepared in a way that will simply overwrite the previously compiled version.\n\n#Exercise\n\n## Step 1\n\nCompile the test suite. You can easily do that by copy / pasting (let's call\nthat _installing_ for simplicity) into your terminal connected to a mounted\nOracle database.\n\nThis will fail, complaining that there is no package called `HAMMING#`.\n\nTo fix the error create the package by installing the prepared solution stub.\nNote that you will have to re-install the package body of `UT_HAMMING#`.\n\nA few words about naming: the `#` at the end of the name signifies that this\nis a package. `UT` means _unit test_. _PL/SQL_ has a maximum identifier length\nof 30 characters, which is why you will find that many words are abbreviated.\n\nIf you've worked with PL/SQL before, you might wonder why the template is a\npackage and not simply a standalone function. That would of course also be a\npossibility, but in practice standalone procedures or functions are rarely used.\n\n## Step 2\n\nTry to run the test. You will notice that you are missing the function's\nimplementation. Create it (see the test package for examples).\n\nNote that functions have to return a value, so for now just `return null;`.\n\n## Step 3\n\nRun the test again. It should now execute, but the test will fail.\nThat's where you get to actually implement the function!\n\n## Wash, Rinse, Repeat\n\nOnly the first test is enabled at first, the others are commented out. To enable\nthem, simply delete the `--` in front of the procedure call and they'll run\nwhen you next install the test package!\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hamming#.plsql\n\n",
        "hamming#.plsql": "create or replace package hamming#\nis\n  --+--------------------------------------------------------------------------+\n  -- Computes the Hamming distance between two starnds.\n  --\n  -- @param i_first  sequence to compare\n  -- @param i_second sequence to compare\n  --\n  -- @return         Hamming distance between i_first and i_second\n  --+--------------------------------------------------------------------------+\n  function distance (\n    i_first                                       varchar2\n   ,i_second                                      varchar2\n  ) return pls_integer;\n\nend hamming#;\n/\n\ncreate or replace package body hamming#\nis\n\nend hamming#;\n/\n",
        "ut_hamming#.plsql": "create or replace package ut_hamming#\nis\n  procedure run;\nend ut_hamming#;\n/\n\ncreate or replace package body ut_hamming#\nis\n\n  procedure test (\n    i_descn                                       varchar2\n   ,i_exp                                         pls_integer\n   ,i_act                                         pls_integer\n  )\n  is\n  begin\n    if i_exp = i_act then\n      dbms_output.put_line('SUCCESS: ' || i_descn);\n    else\n      dbms_output.put_line(\n           'FAILURE: '   || i_descn\n        || ': expected ' || nvl('' || i_exp, 'null')\n        || ', but got '  || nvl('' || i_act, 'null')\n        || '!'\n      );\n    end if;\n  end test;\n\n  procedure run\n  is\n  begin\n    test('test_no_difference_between_identical_strands'                    , 0, hamming#.distance(i_first => 'A'           , i_second => 'A'           ));\n    --test('test_complete_hamming_distance_of_for_single_nucleotide_strand', 1, hamming#.distance(i_first => 'A'           , i_second => 'G'           ));\n    --test('test_complete_hamming_distance_of_for_small_strand'            , 2, hamming#.distance(i_first => 'AG'          , i_second => 'CT'          ));\n    --test('test_small_hamming_distance'                                   , 1, hamming#.distance(i_first => 'AG'          , i_second => 'AT'          ));\n    --test('test_small_hamming_distance_in_longer_strand'                  , 1, hamming#.distance(i_first => 'GGACG'       , i_second => 'GGTCG'       ));\n    --test('test_nonunique_characters_within_first_strand'                 , 1, hamming#.distance(i_first => 'AGA'         , i_second => 'AGG'         ));\n    --test('test_nonunique_characters_within_second_strand'                , 1, hamming#.distance(i_first => 'AGG'         , i_second => 'AGA'         ));\n    --test('test_large_hamming_distance'                                   , 4, hamming#.distance(i_first => 'GATACA'      , i_second => 'GCATAA'      ));\n    --test('test_hamming_distance_in_very_long_strand'                     , 9, hamming#.distance(i_first => 'GGACGGATTCTG', i_second => 'AGGACGGATTCT'));\n  exception\n    when others then\n      dbms_output.put_line('Test execution failed.');\n      dbms_output.put_line(sqlerrm);\n  end run;\n\nend ut_hamming#;\n/\n\nbegin\n  ut_hamming#.run;\nend;\n/\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n## Setup\n\nGo through the setup instructions for PL/SQL to get ready to code:\n\nhttp://help.exercism.io/getting-started-with-plsql.html\n\n## Running the Tests\n\nExecute the tests by calling the `run` method in the respective `ut_<exercise>#` package.\nThe necessary code should be contained at the end of the test package.\nAs an example, the test for the _hamming_ exercise would be run using\n\n```\nbegin\n  ut_hamming#.run;\nend;\n/\n```\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "track_id": "python",
      "id": "hello-world",
      "track": "python",
      "slug": "hello-world",
      "files": {
        "hello_world.py": "#\n# Skeleton file for the Python \"Hello World\" exercise.\n#\ndef hello(name = ''):\n\n    return\n",
        "hello_world_test.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nimport unittest\n\nimport hello_world\n\n\nclass BobTests(unittest.TestCase):\n\n    def test_hello_without_name(self):\n        self.assertEqual(\n            'Hello, world!',\n            hello_world.hello()\n        )\n    def test_hello_with_name(self):\n        self.assertEqual(\n            'Hello, Jane!',\n            hello_world.hello('Jane')\n        )\n\n    def test_hello_with_umlaut_name(self):\n        self.assertEqual(\n            'Hello, Jürgen!',\n            hello_world.hello('Jürgen')\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure the solution is in the `exercism/python/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.py` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/python/bob/bob.py`.\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "ruby",
      "id": "hello-world",
      "track": "ruby",
      "slug": "hello-world",
      "files": {
        "hello_world_test.rb": "require 'minitest/autorun'\nrequire_relative 'hello_world'\nclass HelloWorldTest < Minitest::Test\n  def test_no_strange_name\n    assert_equal 'Hello, !', HelloWorld.hello(''), 'When giving an empty string, it is strange, but should have a space and punctuation'\n  end\n\n  def test_no_name\n    assert_equal 'Hello, world!', HelloWorld.hello, 'When giving no name, we should greet the world!'\n  end\n\n  def test_sample_name\n    assert_equal 'Hello, Alice!', HelloWorld.hello('Alice'), 'When giving \"Alice\" we should greet Alice!'\n  end\n\n  def test_other_sample_name\n    assert_equal 'Hello, Bob!', HelloWorld.hello('Bob'), 'When giving \"Bob\" we should greet Bob!'\n  end\nend\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nRefer exercism help page at http://help.exercism.io/getting-started-with-ruby.html for ruby installation and learning resources.\n\nFor running the tests provided, you will need the Minitest gem. Open a terminal window and run the following command to install minitest:\n\n    gem install minitest\n\nIn order to run the test, you can run the test file from the exercise directory. For example, if the test suite is called `hello_world_test.rb`, you can run the following command:\n\n    ruby hello_world_test.rb\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "scala",
      "id": "hello-world",
      "track": "scala",
      "slug": "hello-world",
      "files": {
        "build.sbt": "scalaVersion := \"2.10.3\"\n\nlibraryDependencies += \"org.scalatest\" % \"scalatest_2.10\" % \"2.0\" % \"test\"\n",
        "src/test/scala/HelloWorldTest.scala": "import org.scalatest.{Matchers, FunSuite}\n\nclass HelloWorldTest extends FunSuite with Matchers {\n  test(\"Without name\") {\n    HelloWorld.hello() should be (\"Hello, world!\")\n  }\n\n  test(\"with name\") {\n    HelloWorld.hello(\"Jane\") should be (\"Hello, Jane!\")\n  }\n\n  test(\"with umlaut name\") {\n    HelloWorld.hello(\"Jürgen\") should be (\"Hello, Jürgen!\")\n  }\n}\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nThe Scala exercises assume an SBT project scheme. The exercise solution source\nshould be placed within the exercise directory/src/main/scala. The exercise\nunit tests can be found within the exercise directory/src/test/scala.\n\nTo run the tests simply run the command `sbt test` in the exercise directory.\n\nFor more detailed info about the Scala track see the [help\npage](http://help.exercism.io/getting-started-with-scala.html).\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "scheme",
      "id": "hello-world",
      "track": "scheme",
      "slug": "hello-world",
      "files": {
        "hello-world-test.scm": ";; Load SRFI-64 lightweight testing specification\n(use-modules (srfi srfi-64))\n\n;; Suppress log file output. To write logs, comment out the following line:\n(module-define! (resolve-module '(srfi srfi-64)) 'test-log-to-file #f)\n\n;; Require module\n(add-to-load-path (dirname (current-filename)))\n(use-modules (hello-world))\n\n(test-begin \"hello-world\")\n\n(test-assert \"Called with no args returns hello world\"\n             (equal? (hello)\n                     \"Hello, world!\"))\n\n(test-assert \"Called with an arg returns hello arg\"\n             (equal? (hello \"exercism\")\n                     \"Hello, exercism!\"))\n\n(test-end \"hello-world\")\n",
        "hello-world.scm": "(define-module (hello-world)\n  #:export (hello))\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello world!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, world!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nNo additional dependencies should be required.\n\nSometimes module functions will be loaded that are useful to the problem case.\nYou'll see them in the `define-package` macro at the top of the source file,\nthus: `#:autoload (mod submod) (function0 function1)`. The curious can read\nabout included modules [here][0].\n\nIf you need help getting set up, see [Getting Started With Scheme][1]\nin the [Exercism.io Help][2] pages.\n\n[0]: https://www.gnu.org/software/guile/docs/docs-2.0/guile-ref/Included-Guile-Modules.html\n[1]: http://help.exercism.io/getting-started-with-scheme.html\n[2]: http://help.exercism.io\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "track_id": "swift",
      "id": "leap",
      "track": "swift",
      "slug": "leap",
      "files": {
        "LeapTest.swift": "import XCTest\n\nclass LeapTest : XCTestCase {\n\n\tfunc testVanillaLeapYear() {\n\t  let year = Year(calendarYear: 1996)\n\t  XCTAssertTrue(year.isLeapYear)\n\t}\n\n\tfunc testAnyOldYear() {\n\t  let year = Year(calendarYear: 1997)\n\t  XCTAssertTrue(!year.isLeapYear)\n\t}\n\n\tfunc testCentury() {\n\t  let year = Year(calendarYear: 1900)\n\t  XCTAssertTrue(!year.isLeapYear)\n\t}\n\n\tfunc testExceptionalCentury() {\n\t  let year = Year(calendarYear: 2400)\n\t  XCTAssertTrue(year.isLeapYear)\n\t}\n\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n## Setup\r\n\r\nGo through the project setup instructions for Xcode using Swift:\r\n\r\nhttp://help.exercism.io/getting-started-with-swift.html\r\n\r\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    }
  ]
}
